#this is the display application for Aeonix

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QGridLayout,
    QLabel, QLineEdit, QPushButton, QGroupBox, QCheckBox, QTextEdit, QDialog,
    QListWidget, QListWidgetItem, QSizePolicy, QProgressBar
)
from PySide6.QtCore import Qt, QTimer, QUrl, QEvent, Signal, QObject
from PySide6.QtGui import QColor, QFont
from PySide6.QtWebEngineWidgets import QWebEngineView
from PySide6.QtWebEngineCore import QWebEngineSettings
from PySide6.QtCore import QMetaObject, Qt, Q_ARG
from concurrent.futures import ThreadPoolExecutor
from geopy.distance import geodesic
from datetime import datetime
import time
import sys
import os
import requests
import json
from tornado_scoring import score_conditions, score_to_color


class AlertFetcher(QObject):
    alerts_ready = Signal(list)

    def fetch(self):
        #print("[INIT] Launching alert fetch thread...")
        try:
            r = requests.get("https://api.weather.gov/alerts/active", timeout=8)
            r.raise_for_status()
            data = r.json()
            alerts = data.get("features", [])
            #print(f"[FETCHED] Got {len(alerts)} alerts.")
            self.alerts_ready.emit(alerts)
        except Exception as e:
            print(f"[ERROR] Fetch failed: {e}")
            self.alerts_ready.emit([])

class LoadingDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Initializing Aeonix Stream...")
        self.setModal(True)
        self.setMinimumSize(360, 180)

        self.status_label = QLabel("Starting connection check...")
        self.status_label.setAlignment(Qt.AlignCenter)

        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)

        layout = QVBoxLayout()
        layout.addWidget(self.status_label)
        layout.addWidget(self.progress_bar)
        self.setLayout(layout)

        self.progress_step = 0

    def set_total_steps(self, total):
        self.progress_bar.setRange(0, total)
        self.progress_step = 0
        self.progress_bar.setValue(0)

    def update_status(self, message):
        self.status_label.setText(message)
        self.progress_step += 1
        self.progress_bar.setValue(self.progress_step)



class AeonixStream(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Aeonix Stream - Realtime Weather Monitor")
        self.setMinimumSize(1280, 1000)
        self.executor = ThreadPoolExecutor(max_workers=5)
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        self.layout = QVBoxLayout(central_widget)
        self.refresh_status(first_run=True)
        QTimer.singleShot(1000, self.update_timer)

        # üöÄ Load tracked tornadoes after map is ready
        #QTimer.singleShot(2000, self.load_tracked_tornadoes)

        self.alert_ids_seen = set()
        with open("D:/Aeonix/Core/ugc_centroids_full.json") as f:
            self.ugc_centroids = json.load(f)
        self.cached_polygons = {
            "watch": [],
            "warning": []
        }
        self.cached_ml_tracks = []  # üîÅ JS strings to toggle ML data back on

        self.full_refresh_interval = 5 * 60  # 5 minutes
        self.time_remaining = self.full_refresh_interval

        self.init_top_bar()
        self.init_status_monitor()  # ‚úÖ add this back
        self.init_map_controls()  # ‚úÖ add this back
        self.init_main_display()
        self.init_alert_log()

        self.fetcher = AlertFetcher()
        self.fetcher.alerts_ready.connect(self.process_alerts)

        QTimer.singleShot(100, self.load_alerts_async)

        self.main_split.setStretch(0, 3)  # map column (index 0)
        self.main_split.setStretch(1, 1)  # alert sidebar column (index 1)def

        self.refresh_status(first_run=True)
        QTimer.singleShot(1000, self.update_timer)



    def toggle_tornado_tracks(self, visible):
        # Clear all tracks first
        self.map_widget.page().runJavaScript("clearTornadoTracks();")

        if visible:
            for js in self.cached_polygons.get("tornado", []):
                self.map_widget.page().runJavaScript(js)

        print(f"[TOGGLE] Tornado tracks ‚Üí {'ON' if visible else 'OFF'}")


    def schedule_alert_processing(self, alerts):
        """Run alert processing safely on the Qt main thread."""
        QTimer.singleShot(0, lambda: self.process_alerts(alerts))

    def reset_update_bar(self):
        mins, secs = divmod(self.time_remaining, 60)
        self.update_progress.setFormat(f"Next update in {mins:02}:{secs:02}")
        self.update_progress.setMaximum(self.full_refresh_interval)
        self.update_progress.setValue(0)


    def toggle_map_layer(self, layer_type, visible):
        checkboxes = {
            "watch": self.cb_watches,
            "warning": self.cb_warnings
        }

        # Clear all first
        if self.map_ready:
            self.map_widget.page().runJavaScript("clearAlertMarkers();")
        else:
            print("[JS SKIP] Map not ready for clearAlertMarkers.")

        # Redraw what's currently checked
        for lt in ["watch", "warning"]:
            if checkboxes[lt].isChecked():
                for js in self.cached_polygons.get(lt, []):
                    self.map_widget.page().runJavaScript(js)

        print(
            f"[TOGGLE] {layer_type} ‚Üí {'ON' if visible else 'OFF'} | Watch count: {len(self.cached_polygons['watch'])} | Warning count: {len(self.cached_polygons['warning'])}")

    def toggle_radar(self, visible):
        if self.map_ready:
            self.map_widget.page().runJavaScript(f"toggleRadarLayer({str(visible).lower()});")
        else:
            print("[JS SKIP] Map not ready for toggleRadarLayer.")

    def process_alerts(self, alerts):
        print(f"[INFO] Received {len(alerts)} alerts from NWS")

        # üîÅ Trim to relevant alerts only
        filtered_alerts = []
        chunked_alerts = filtered_alerts[:150]  # or any cap you want
        for alert in chunked_alerts:
            props = alert.get("properties", {})
            geo = alert.get("geometry", {})
            event_lower = props.get("event", "").lower()
            ends = props.get("ends", "")

            if not any(k in event_lower for k in ["tornado", "severe thunderstorm"]):
                continue
            if geo.get("type") != "Polygon":
                continue
            if ends and ends < datetime.utcnow().isoformat():
                continue

            filtered_alerts.append(alert)

        print(f"[INFO] Filtered to {len(filtered_alerts)} active polygon alerts")

        # üö´ Hard cap to avoid overload
        max_alerts = 150
        chunked_alerts = filtered_alerts[:max_alerts]

    def safe_enrich_later(self, retries=10):
        """Ensures the map is loaded before enriching with weather data."""
        if not self.map_widget or not self.map_widget.page():
            print("[SAFE ENRICH] Map widget or page not available yet.")
            return

        url = self.map_widget.page().url().toString()
        if url == "" or url.startswith("about:blank"):
            print(f"[SAFE ENRICH] Map not ready (blank URL). Retries left: {retries}")
            if retries > 0:
                QTimer.singleShot(500, lambda: self.safe_enrich_later(retries - 1))
            return

        print(f"[SAFE ENRICH] Map is ready. Proceeding with enrichment.")
        self.safe_enrich_later()


    def enrich_watch_zones_with_weather(self):
        import requests
        from PySide6.QtCore import QDateTime

        self.alert_log.append("[DATA] Enriching tornado watches with live surface variables...\n")

        for item_index in range(self.alert_list.count()):
            item = self.alert_list.item(item_index)
            label = item.text()
            coords = item.data(Qt.UserRole + 1)

            if coords:
                lat, lon = coords
                points = [(lat, lon)] + self.generate_cardinal_points(lat, lon)

                self.alert_log.append(f"üìç {label} - Weather Sample:\n")
                for idx, (pt_lat, pt_lon) in enumerate(points):
                    url = (
                        f"https://api.open-meteo.com/v1/forecast?"
                        f"latitude={pt_lat:.4f}&longitude={pt_lon:.4f}&current=cape,cin,dewpoint_2m,wind_speed_10m"
                    )

                    try:
                        r = requests.get(url, timeout=4)
                        r.raise_for_status()
                        current = r.json().get("current", {})
                        score = score_conditions(current)
                        color = score_to_color(score)

                        self.alert_log.append(
                            f"  ‚Ä¢ Point {idx}: "
                            f"Score={score}% | Color={color} | "
                            f"CAPE={current.get('cape')} CIN={current.get('cin')} "
                            f"DewPt={current.get('dewpoint_2m')} Wind={current.get('wind_speed_10m')}"
                        )

                        # TODO: Later ‚Üí pass `score` and `color` to JS to draw colored dots
                        # Example: self.map_widget.page().runJavaScript(drawDot(pt_lat, pt_lon, color))

                    except Exception as e:
                        self.alert_log.append(f"  ‚Ä¢ Point {idx}: ERROR ‚Üí {str(e)}")

                self.alert_log.append("")

        self.alert_log.append(f"[DONE] Watch zone enrichment complete at {QDateTime.currentDateTime().toString()}\n")

    def handle_alert_click(self, item):
        # Show full NWS alert content
        self.alert_log.setText(item.data(Qt.UserRole))

        # Retrieve stored coordinates if available
        coords = item.data(Qt.UserRole + 1)

        if coords:
            lat, lon = coords
            zoom_level = 8  # üîç Adjust zoom level as desired (higher = closer)
            js = f"map.setView([{lat}, {lon}], {zoom_level});"
            self.map_widget.page().runJavaScript(js)
            print(f"[ZOOM] Centered map on alert: {lat}, {lon}")
        else:
            print("[ZOOM] No coordinates found for this alert.")

    def generate_cardinal_points(self, lat, lon, distance_miles=20):
        """Returns 4 lat/lon points ~20 miles N, E, S, W from center."""
        import math
        earth_radius = 3958.8  # in miles
        d_rad = distance_miles / earth_radius
        lat_rad = math.radians(lat)
        lon_rad = math.radians(lon)
        bearings = [0, math.pi / 2, math.pi, 3 * math.pi / 2]  # N, E, S, W
        points = []

        for b in bearings:
            new_lat = math.asin(math.sin(lat_rad) * math.cos(d_rad) +
                                math.cos(lat_rad) * math.sin(d_rad) * math.cos(b))
            new_lon = lon_rad + math.atan2(math.sin(b) * math.sin(d_rad) * math.cos(lat_rad),
                                           math.cos(d_rad) - math.sin(lat_rad) * math.sin(new_lat))
            points.append((math.degrees(new_lat), math.degrees(new_lon)))

        return points

    def changeEvent(self, event):
        if event.type() == QEvent.WindowStateChange:
            if self.isMaximized():
                self.map_widget.setMinimumHeight(1000)
                self.alert_list_box.setFixedWidth(400)  # wider sidebar
            else:
                self.map_widget.setMinimumHeight(600)
                self.alert_list_box.setFixedWidth(300)
        super().changeEvent(event)

    def init_top_bar(self):
        top_bar = QHBoxLayout()
        self.zip_input = QLineEdit()
        self.zip_input.setPlaceholderText("Enter ZIP code")
        self.search_button = QPushButton("Search")
        self.refresh_button = QPushButton("Refresh Now")

        self.update_progress = QProgressBar()
        self.update_progress.setMinimum(0)
        self.update_progress.setMaximum(self.full_refresh_interval)
        self.update_progress.setValue(0)
        self.update_progress.setTextVisible(True)
        #self.update_progress.setFormat("Next update in %m:%s")

        top_bar.addWidget(self.update_progress)
        top_bar.addWidget(self.zip_input)
        top_bar.addWidget(self.search_button)
        top_bar.addStretch()
        top_bar.addWidget(self.refresh_button)

        self.refresh_button.clicked.connect(self.manual_refresh)
        self.layout.addLayout(top_bar)

    def init_map_controls(self):
        controls = QGroupBox("Map Layers")
        layout = QHBoxLayout()

        self.cb_watches = QCheckBox("Show Watches")
        self.cb_warnings = QCheckBox("Show Warnings")
        self.cb_radar = QCheckBox("Show Radar")
        self.cb_tracked = QCheckBox("Show Tracked Zones")
        self.cb_threats = QCheckBox("Show Detected Threats")
        self.cb_ml_data = QCheckBox("Show ML Data")  # ‚úÖ NEW ML layer checkbox

        self.cb_watches.setChecked(True)
        self.cb_warnings.setChecked(True)
        self.cb_radar.setChecked(True)
        self.cb_ml_data.setChecked(True)  # ‚úÖ Start ML toggle as enabled

        # Connect toggles to their handlers
        self.cb_watches.stateChanged.connect(lambda _: self.toggle_map_layer("watch", self.cb_watches.isChecked()))
        self.cb_warnings.stateChanged.connect(lambda _: self.toggle_map_layer("warning", self.cb_warnings.isChecked()))
        self.cb_radar.stateChanged.connect(lambda _: self.toggle_radar(self.cb_radar.isChecked()))
        #self.cb_ml_data.stateChanged.connect(
            #lambda _: self.toggle_ml_data(self.cb_ml_data.isChecked()))  # ‚úÖ ML toggle hook

        # Add checkboxes to layout
        layout.addWidget(self.cb_watches)
        layout.addWidget(self.cb_warnings)
        layout.addWidget(self.cb_radar)
        layout.addWidget(self.cb_tracked)
        layout.addWidget(self.cb_threats)
        layout.addWidget(self.cb_ml_data)  # ‚úÖ Add to layout

        controls.setLayout(layout)
        self.layout.addWidget(controls)

    def on_map_ready(self, ok):
        self.map_ready = ok
        print(f"[MAP LOAD COMPLETE] Status: {'‚úÖ OK' if ok else '‚ùå Failed'}")

    def init_status_monitor(self):
        self.status_box = QGroupBox("System Status")
        grid = QGridLayout()

        self.grib_status = QLabel("GRIB2 Feed: ‚è≥")
        self.radar_status = QLabel("Radar Feed: ‚è≥")
        self.alerts_status = QLabel("Alerts API: ‚è≥")
        self.surface_status = QLabel("Surface Data: ‚è≥")

        grid.addWidget(self.grib_status, 0, 0)
        grid.addWidget(self.radar_status, 0, 1)
        grid.addWidget(self.alerts_status, 1, 0)
        grid.addWidget(self.surface_status, 1, 1)

        self.status_box.setLayout(grid)
        self.layout.addWidget(self.status_box)

    def init_main_display(self):
        self.main_split = QHBoxLayout()

        # üó∫Ô∏è Map
        self.map_widget = QWebEngineView()
        self.map_widget.setMinimumHeight(600)
        self.map_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.map_widget.setUrl(QUrl("http://localhost:8050/base_map.html"))
        self.map_ready = False
        self.map_widget.loadFinished.connect(self.on_map_ready)

        self.main_split.addWidget(self.map_widget)

        # üìã Sidebar List
        self.alert_list_box = QGroupBox("Active Alerts")
        alert_list_layout = QVBoxLayout()
        self.alert_list = QListWidget()
        self.alert_list.itemClicked.connect(self.handle_alert_click)
        alert_list_layout.addWidget(self.alert_list)
        self.alert_list_box.setLayout(alert_list_layout)
        self.alert_list_box.setFixedWidth(320)
        self.main_split.addWidget(self.alert_list_box)

        self.layout.addLayout(self.main_split)

    def init_alert_log(self):
        self.alert_log = QTextEdit()
        self.alert_log.setReadOnly(True)
        self.alert_log.setPlaceholderText("Click an alert to view full details.")
        self.layout.addWidget(self.alert_log)

    def load_alerts_async(self):
        self.alert_list.clear()
        placeholder = QListWidgetItem("Fetching watches and warnings...")
        placeholder.setForeground(QColor("gray"))
        self.alert_list.addItem(placeholder)
        self.executor.submit(self.fetcher.fetch)

    def update_timer(self):
        self.time_remaining -= 1
        progress = self.full_refresh_interval - self.time_remaining
        self.update_progress.setValue(progress)

        mins, secs = divmod(self.time_remaining, 60)
        self.update_progress.setFormat(f"Next update in {mins:02}:{secs:02}")

        if self.time_remaining <= 0:
            self.refresh_status()
            self.time_remaining = self.full_refresh_interval
            self.update_progress.setValue(0)

        QTimer.singleShot(1000, self.update_timer)  # <- Ensures continual countdown

    def manual_refresh(self):
        self.refresh_status()
        self.time_remaining = self.full_refresh_interval
        self.update_progress.setValue(0)

    def initial_refresh(self):
        self.loading_dialog = LoadingDialog(self)
        self.loading_dialog.show()
        QTimer.singleShot(100, self.refresh_status)

    def refresh_status(self, first_run=False):
        QTimer.singleShot(100, self.load_alerts_async)
        now = time.time()
        print("[DEBUG] refresh_status called")

        if not hasattr(self, 'last_check'):
            self.last_check = {
                "GRIB2": 0,
                "Radar": 0,
                "Surface": 0,
                "Alerts": 0
            }
            self.check_intervals = {
                "GRIB2": 15 * 60,  # every 15 minutes
                "Radar": 5 * 60,  # every 5 minutes
                "Surface": 5 * 60,  # every 5 minutes
                "Alerts": 5 * 60  # every 5 minutes
            }

        tasks = []
        if now - self.last_check["GRIB2"] >= self.check_intervals["GRIB2"]:
            tasks.append(("GRIB2", self.check_grib))
            self.last_check["GRIB2"] = now
        if now - self.last_check["Radar"] >= self.check_intervals["Radar"]:
            tasks.append(("Radar", self.check_radar))
            self.last_check["Radar"] = now
        if now - self.last_check["Surface"] >= self.check_intervals["Surface"]:
            tasks.append(("Surface", self.check_surface))
            self.last_check["Surface"] = now
        if now - self.last_check["Alerts"] >= self.check_intervals["Alerts"]:
            tasks.append(("Alerts", self.check_alert_api))
            self.last_check["Alerts"] = now

        self.completed_tasks = 0
        for name, func in tasks:
            self.executor.submit(self.wrap_status_check, name, func)

        if first_run:
            print("[INIT] First data pull complete. Countdown started.")

        QTimer.singleShot(100, self.load_alerts_async)

    def set_status_label(self, name, message):
        print(f"[UI UPDATE] Setting {name} ‚Üí {message}")
        label_map = {
            "GRIB2": self.grib_status,
            "Radar": self.radar_status,
            "Surface": self.surface_status,
            "Alerts": self.alerts_status
        }

        if name in label_map:
            label = label_map[name]
            now = datetime.now().strftime("%H:%M:%S")

            if "Available" in message or "Connected" in message or "OK" in message or "Live" in message:
                label.setText(f"{name}: {message} @ {now}")
            else:
                label.setText(f"{name}: {message}")  # fallback (hourglass)

    def wrap_status_check(self, name, func):
        print(f"[DEBUG] wrap_status_check() called for {name}")
        result = "Unknown"
        try:
            result = func()
            print(f"[DEBUG] {name} check returned ‚Üí {result}")
        except Exception as e:
            result = f"ERROR: {e}"
            print(f"[DEBUG] {name} raised an error ‚Üí {result}")

        # ‚úÖ THIS WORKS
        def call_status_update():
            self.set_status_label(name, result)

        QTimer.singleShot(0, call_status_update)

        print(f"[CHECK COMPLETE] {name}: {result}")

    def check_internet(self):
        requests.get("https://google.com", timeout=3)
        return "Connected"

    def check_grib(self):
        r = requests.head("https://noaa-hrrr-bdp-pds.s3.amazonaws.com/index.html", timeout=5)
        return "Available" if r.status_code == 200 else "Unavailable"

    def check_radar(self):
        r = requests.head("https://mesonet.agron.iastate.edu/data/nexrad/composite/n0q_0_latest.png", timeout=5)
        return "Connected" if r.status_code == 200 else "Unavailable"

    def check_surface(self):
        r = requests.get("https://mesonet.agron.iastate.edu/request/asos/1min.csv?station=KOKC", timeout=5)
        return "OK" if r.status_code == 200 else "Unavailable"

    def check_alert_api(self):
        r = requests.get("https://api.weather.gov/alerts/active", timeout=5)
        return "Live" if r.status_code == 200 else "Down"





if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = AeonixStream()
    window.show()
    sys.exit(app.exec())
